\subsection{Tree ordering}
\label{sec:treeorder}	
%Another objective at the HIR is to reduce the number of trees that need to be specialized by the lower levels.   
% \TODO{kr : Not sure if i got this para right}
Specializing the code for each tree in a model comes at a cost. First, the size of the generated code increases if the
code generator needs to generate different code for different trees. This causes several front end stalls like instruction 
cache misses and delays in instruction decoding. Second, some cross tree optimizations 
like tree walk interleaving (applied at the lower levels of abstraction) are more effective when multiple trees share identical code. 

In order to handle this, \Treebeard{} groups trees by their structure so that trees with the same structure can 
share code. For example, the compiler pads trees with dummy tiles to make them balanced and then sorts the trees by 
their depth, so that trees of same depth can share the same unrolled tree walk. Padding is only done for almost balanced trees (as generated 
by basic tiling). This is shown in the example in figure \ref{Fig:Overview}. Other metrics, like feature set commonality, 
could also be used to reorder trees\cite{Tahoe}. However, we leave the exploration of such optimizations to future work.

% , this is ensured by only adding up to a fixed fraction of dummy nodes. \TODO{Kr : Can we add a threshold say 10\%?}
%This ensures that all trees with equal depth are grouped together.
\CommentOut{ 
Once this is done, the loop over the trees is fissed so that each of the resulting loops only walks trees of a single depth. Consider for example a 
forest with 4 trees $T_1$, $T_2$, $T_3$, and $T_4$ in that order. Further, assume that $T_1$ and $T_4$ have depth 2 while $T_2$ and $T_3$
have depth 3. First, Treebeard reorders the trees to be in the order $T_1$, $T_4$, $T_2$, $T_3$. Then, the loop over the trees is fissed
as shown in the following listing.

% loop transformations for basic tiling (splitting) 
\begin{lstlisting}{style=c++}
  forest = ensemble(...)
  for i = 0 to batchSize step 1 {
    prediction = 0
    for t = 0 to 2 step 1 {
      tree = getTree(forest, t) 
      node = getRoot(tree)
      node = traverseTreeTile(tree, node, rows[i])
      treePrediction = getLeafValue(tree, node)
      prediction = prediction + treePrediction
    }
    for t = 2 to 4 step 1 {
      tree = getTree(forest, t) 
      node = getRoot(tree)
      node = traverseTreeTile(tree, node, rows[i])
      node = traverseTreeTile(tree, node, rows[i])
      treePrediction = getLeafValue(tree, node)
      prediction = prediction + treePrediction
    }
    predictions[i] = prediction
  }  
\end{lstlisting}
}
