\subsection{Tree ordering}
\label{sec:treeorder}	
%Another objective at the HIR is to reduce the number of trees that need to be specialized by the lower levels.   
\TODO{kr : Not sure if i got this para right}
Specializing the code for each tree in a model comes at a cost. First the code generator needs to generate different code for different trees potentially increasing the size of the generated code. Second some cross tree optimizations (applied at the lower levels of abstraction) like tree walk interleaving require that the multiple trees share identical code. 

In order to handle
this, \Treebeard{} pads trees with dummy nodes to make them balanced and then sorts the trees by their depth, so that trees of same depth can share code. Padding is only done for almost balanced trees (as generated by basic tiling), this is ensured by only adding up to a fixed fraction of dummy nodes.  
\TODO{Kr : Can we add a threshold say 10\%?}
%This ensures that all trees with equal depth are grouped together.
 Once this is done, 
the loop over the trees is fissed so that each of the resulting loops only walks trees of a single depth. Consider for example a 
forest with 4 trees $T_1$, $T_2$, $T_3$, and $T_4$ in that order. Further, assume that $T_1$ and $T_4$ have depth 2 while $T_2$ and $T_3$
have depth 3. First, Treebeard reorders the trees to be in the order $T_1$, $T_4$, $T_2$, $T_3$. Then, the loop over the trees is fissed
as shown in the following listing.

% loop transformations for basic tiling (splitting) 
\begin{lstlisting}{style=c++}
  forest = ensemble(...)
  for i = 0 to batchSize step 1 {
    prediction = 0
    for t = 0 to 2 step 1 {
      tree = getTree(forest, t) 
      node = getRoot(tree)
      node = traverseTreeTile(tree, node, rows[i])
      treePrediction = getLeafValue(tree, node)
      prediction = prediction + treePrediction
    }
    for t = 2 to 4 step 1 {
      tree = getTree(forest, t) 
      node = getRoot(tree)
      node = traverseTreeTile(tree, node, rows[i])
      node = traverseTreeTile(tree, node, rows[i])
      treePrediction = getLeafValue(tree, node)
      prediction = prediction + treePrediction
    }
    predictions[i] = prediction
  }  
\end{lstlisting}

