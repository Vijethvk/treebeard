\subsection{Uniform Tiling}
% The justification for uniform tiling -- if we assume all paths are equally likely,
% we want to minimize the depth of speculation
The first tree tiling algorithm we implement is uniform tiling. The basic idea of uniform tiling is to construct tiles
with a tile size $n_t$ so that we evaluate 
the least possible number of nodes speculatively. Intuitively, this translates to minimizing the height of the constructed tile. We minimize
the height of the tile by performing a level order traversal starting at the root node of the tile. 
\TODO{AP Should we say this is optimal when probabilities are equal? Problem is we haven't said what optimal is.}
This traversal collects at most $n_t$ nodes
and does not include any leaves in the tile so that the constraints listed in section \ref{sec:ValidTiling} are respected. Algorithm 
\ref{Alg:UnifTilingAlgo} lists the algorithm for uniform tiling. Tiling starts at the root and constructs a tile $Tile$ by performing
a level order traversal. Once the current tile is constructed, the tiling procedure is recursively performed on all nodes that are 
destinations for edges going out of the constructed tile. The set of tiles constructed by algorithm \ref{Alg:UnifTilingAlgo} constitutes 
a uniform tiling of the input tree.
% Algorithm for uniform tiling
\begin{algorithm}
  \caption{Uniform tree tiling}
  \label{Alg:UnifTilingAlgo}
  \begin{algorithmic}
      \Procedure{TileTree}{$T = (V, E, r)$, $n_t$} 
          \If {$r \in L$}
              \State \textbf{return} $\{ r \}$
          \EndIf
          \State \textcolor{codegreen}{\textit{//Level order traversal to collect $n_t$ or fewer nodes. }}
          \State \textcolor{codegreen}{\textit{//Leaves are not included in the constructed tile. }}
          \State $Tile \leftarrow LevelOrderTraveral(r, n_t)$
          \State $Tiles =  \{ Tile \}$
          \For{$(u,v) \in Out(Tile)$}
              \State $Tiles \leftarrow Tiles \cup TileTree(T_v, n_t)$
          \EndFor
          \State \textbf{return} $Tiles$
      \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsubsection{Further Opimization and Code Generation}
We found that most leaf tiles for a given tree are at the same depth when uniform tiling is used. Furthermore, we see that deeper leaves 
are more likely to be reached.
%\footnote{Intuitively, this is true because training algorithms keep splitting nodes to maximize gain and gain
%will typically be maximized by splitting a large number of inputs.}.
Based on these observations, we pad the tree of tiles generated with uniform tiling so that all leaves are at the same depth.
This transformation is performed on the high level IR after uniform tiling. 
Once the trees have been padded to make all leaves equal depth, the tree walks are fully unrolled to evaluate a fixed 
number of tiles and all leaf checks are elided.

One other complication the code generator needs to handle is the fact that trees potentially have different depths. In order to handle
this, Treebeard sorts the trees by their depth. This ensures that all trees with equal depth are grouped together. Once this is done, 
the loop over the trees is fissed so that each of the resulting loops only walks trees of a single depth. Consider for example a 
forest with 4 trees $T_1$, $T_2$, $T_3$, and $T_4$ in that order. Further, assume that $T_1$ and $T_4$ have depth 2 while $T_2$ and $T_3$
have depth 3. First, Treebeard reorders the trees to be in the order $T_1$, $T_4$, $T_2$, $T_3$. Then, the loop over the trees is fissed
as shown in the following listing.

% loop transformations for uniform tiling (splitting) 
\begin{lstlisting}{style=c++}
  forest = ensemble(...)
  for i = 0 to batchSize step 1 {
    prediction = 0
    for t = 0 to 2 step 1 {
      tree = getTree(forest, t) 
      node = traverseTreeTile(tree, node, rows[i])
      treePrediction = getLeafValue(tree, node)
      prediction = prediction + treePrediction
    }
    for t = 2 to 4 step 1 {
      tree = getTree(forest, t) 
      node = traverseTreeTile(tree, node, rows[i])
      node = traverseTreeTile(tree, node, rows[i])
      treePrediction = getLeafValue(tree, node)
      prediction = prediction + treePrediction
    }
    predictions[i] = prediction
  }  
\end{lstlisting}

\TODO{AP: This listing is unnecesarily long. Can we maybe leave out the loop bodies and say something like "depth 2 walk"?}