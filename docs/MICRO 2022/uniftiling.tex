\subsection{Basic Tiling}
\label{sec:UnifTiling}
% The justification for basic tiling -- if we assume all paths are equally likely,
% we want to minimize the depth of speculation
Algorithm~\ref{Alg:UnifTilingAlgo} shows the basic tiling algorithm that produces a valid tiling. It 
attempts to minimize the depths of all constructed tiles. 
Tiling starts at the root and constructs a tile $Tile$ by performing
a level order traversal. The call \op{LevelOrderTraversal($\Tree$, $n_t$)} picks the next $n_t$ non-leaf nodes according to the standard 
level order tree traversal algorithm. Once the current tile is constructed, 
the tiling procedure is recursively performed on subtrees rooted at each node that is a destination of an edge going out of the constructed 
tile. It is easy to see that the tiling constructed by Algorithm \ref{Alg:UnifTilingAlgo} is valid.
% \TODO{Pass a modified tree without leaves to the level order traversal call. Explicitly add leaves as seperate tiles}
% Algorithm for basic tiling
\begin{algorithm}
  \caption{Basic tree tiling}
  \label{Alg:UnifTilingAlgo}
  \small{
  \begin{algorithmic}[1]
      \Procedure{LevelOrderTraversal}{$\Tree = (V, E, r)$, $n_t$}
        \State $queue = \{ r \}$
        \State $Tile = \emptyset$
        \While{$\neg queue.empty() \wedge |Tile|<n_t$}
          \State $n = queue.dequeue()$
          \If {$n \in L_{\Tree}$}
              \State \textbf{continue}
          \EndIf
          \State $Tile = Tile \cup \{ n \}$
          \State $queue.enqueue([left(n), right(n)])$
        \EndWhile
      \EndProcedure
      \State {}
      \Procedure{TileTree}{$\Tree = (V, E, r)$, $n_t$} 
          \If {$r \in L_{\Tree}$}
              \State \textbf{return} $\{ r \}$
          \EndIf
          % \State \textcolor{codegreen}{\textit{//Level order traversal to collect $n_t$ or fewer nodes. }}
          % \State \textcolor{codegreen}{\textit{//Leaves are not included in the constructed tile. }}
          \State $Tile \leftarrow LevelOrderTraveral(\Tree, n_t)$
          \State $Tiles =  \{ Tile \}$
          \For{$(u,v) \in Out(Tile)$}
              \State $Tiles \leftarrow Tiles \cup TileTree(S_v, n_t)$
          \EndFor
          \State \textbf{return} $Tiles$
      \EndProcedure
  \end{algorithmic}
  }
\end{algorithm}

One interesting property of this tiling algorithm is that it naturally reduces 
the imbalance in trees, especially at large tile sizes. As the algorithm 
traverses down to sparser levels of the tree, it naturally groups sub-trees 
containing chains of nodes, thus balancing the trees. While it is possible to 
further enhance the algorithm to explicitly balance tiled trees, we find that 
basic tiling suffices in practice.

%%%% COMMENT %%%%% 
\CommentOut{
\subsubsection{Further Opimization and Code Generation}
We found that most leaf tiles for a given tree are at the same depth when basic tiling is used. Furthermore, we see that deeper leaves 
are more likely to be reached.
%\footnote{Intuitively, this is true because training algorithms keep splitting nodes to maximize gain and gain
%will typically be maximized by splitting a large number of inputs.}.
Based on these observations, we (optionally) pad the tree of tiles generated with basic tiling so that all leaves are at the same depth.
This transformation is performed on the high level IR after basic tiling. 
Once the trees have been padded to make all leaves equal depth, the tree walks are fully unrolled to evaluate a fixed 
number of tiles and all leaf checks are omitted.

One other complication the code generator needs to handle is the fact that different trees in the model being 
compiled potentially have different depths. In order to handle
this, Treebeard sorts the trees by their depth. This ensures that all trees with equal depth are grouped together. Once this is done, 
the loop over the trees is fissed so that each of the resulting loops only walks trees of a single depth. Consider for example a 
forest with 4 trees $T_1$, $T_2$, $T_3$, and $T_4$ in that order. Further, assume that $T_1$ and $T_4$ have depth 2 while $T_2$ and $T_3$
have depth 3. First, Treebeard reorders the trees to be in the order $T_1$, $T_4$, $T_2$, $T_3$. Then, the loop over the trees is fissed
as shown in the following listing.

% loop transformations for basic tiling (splitting) 
\begin{lstlisting}{style=c++}
  forest = ensemble(...)
  for i = 0 to batchSize step 1 {
    prediction = 0
    for t = 0 to 2 step 1 {
      tree = getTree(forest, t) 
      node = getRoot(tree)
      node = traverseTreeTile(tree, node, rows[i])
      treePrediction = getLeafValue(tree, node)
      prediction = prediction + treePrediction
    }
    for t = 2 to 4 step 1 {
      tree = getTree(forest, t) 
      node = getRoot(tree)
      node = traverseTreeTile(tree, node, rows[i])
      node = traverseTreeTile(tree, node, rows[i])
      treePrediction = getLeafValue(tree, node)
      prediction = prediction + treePrediction
    }
    predictions[i] = prediction
  }  
\end{lstlisting}

\TODO{AP: This listing is unnecesarily long. Can we maybe leave out the loop bodies and say something like "depth 2 walk"? Should 
we point to the figure in the overview section instead?}
}
%%%% COMMENT END %%%%% 
