# Treebeard Model Representations

This document gives an overview of different in memory representations of the decision tree model used in the code generated by Treebeard.

## Array Based Representation

At a high level, each tree is [represented as an array](https://webdocs.cs.ualberta.ca/~holte/T26/tree-as-array.html). Each element of the array that stores the tree represents a single node (when tile size = 1) or tile (a collection of nodes). Child indices are not explicitly stored.

### Scalar (Tile Size = 1)

Each node of the tree is represented by an object of the following struct.
```C++
template <typename ThresholdType, typename FeatureIndexType>
struct Node {
  ThresholdType threshold;
  FeatureIndexType featureIndex;
};
```
The generated code to walk each tree is the equivalent of the following C++ code.
```C++
// ThresholdType and FeatureIndexType are specified as input to Treebeard (at least currently)
Node<ThresholdType, FeatureIndexType> tree[N]; // Buffer to hold all nodes in the tree

ResultType Prediction_Function(...) {
  // ...
  size_t i = 0;
  while (tree[i].featureIndex != -1) { // While we've not reached a leaf
    ThresholdType feature = x[tree[i].featureIndex]; // Read the required feature from the current row
    size_t comparison = feature >= tree[i].threshold;
    i = 2*i + 1 + comparison; // Move to the left child if (feature < threshold), else right child
  }
  ThresholdType prediction = tree[i].threshold;
  // ...
}
```

